"""Implementation of statechart statechart.
Generated by itemis CREATE code generator.
"""

import queue
import sys, os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../lib')))
from yakindu.rx import Observable

class Statechart:
	"""Implementation of the state machine Statechart.
	"""

	class State:
		""" State Enum
		"""
		(
			global_moving_back_and_forth,
			global_moving_back_and_forth_r1moving_back,
			global_moving_back_and_forth_r1moving,
			global_tired,
			null_state
		) = range(5)
	
	
	class Scheduler:
		"""Implementation of scope Scheduler.
		"""
		
		def __init__(self, statemachine):
			self.set_target_x = None
			self.set_target_x_value = None
			self.set_target_y = None
			self.set_target_y_value = None
			self.make_move = None
			self.ready = None
			self.ready_observable = Observable()
			
			self.statemachine = statemachine
		
		def raise_set_target_x(self, value):
			"""Raise method for event set_target_x.
			"""
			self.statemachine.in_event_queue.put(lambda: self.__raise_set_target_x_call(value))
			self.statemachine.run_cycle()
		
		def __raise_set_target_x_call(self, value):
			"""Raise callback for event set_target_x.
			"""
			self.set_target_x = True
			self.set_target_x_value = value
		
		def raise_set_target_y(self, value):
			"""Raise method for event set_target_y.
			"""
			self.statemachine.in_event_queue.put(lambda: self.__raise_set_target_y_call(value))
			self.statemachine.run_cycle()
		
		def __raise_set_target_y_call(self, value):
			"""Raise callback for event set_target_y.
			"""
			self.set_target_y = True
			self.set_target_y_value = value
		
		def raise_make_move(self):
			"""Raise method for event make_move.
			"""
			self.statemachine.in_event_queue.put(self.__raise_make_move_call)
			self.statemachine.run_cycle()
		
		def __raise_make_move_call(self):
			"""Raise callback for event make_move.
			"""
			self.make_move = True
		
	
	class Emergency:
		"""Implementation of scope Emergency.
		"""
		
		def __init__(self, statemachine):
			self.stop = None
			self.resume = None
			
			self.statemachine = statemachine
		
		def raise_stop(self):
			"""Raise method for event stop.
			"""
			self.statemachine.in_event_queue.put(self.__raise_stop_call)
			self.statemachine.run_cycle()
		
		def __raise_stop_call(self):
			"""Raise callback for event stop.
			"""
			self.stop = True
		
		def raise_resume(self):
			"""Raise method for event resume.
			"""
			self.statemachine.in_event_queue.put(self.__raise_resume_call)
			self.statemachine.run_cycle()
		
		def __raise_resume_call(self):
			"""Raise callback for event resume.
			"""
			self.resume = True
		
	
	class CraneControl:
		"""Implementation of scope CraneControl.
		"""
		
		def __init__(self, statemachine):
			self.move = None
			self.move_value = None
			self.move_observable = Observable()
			self.hoist = None
			self.hoist_value = None
			self.hoist_observable = Observable()
			self.stop_all_movement = None
			self.stop_all_movement_observable = Observable()
			self.done_moving = None
			self.magnet_on = None
			self.magnet_on_observable = Observable()
			self.magnet_off = None
			self.magnet_off_observable = Observable()
			
			self.statemachine = statemachine
		
		def raise_done_moving(self):
			"""Raise method for event done_moving.
			"""
			self.statemachine.in_event_queue.put(self.__raise_done_moving_call)
			self.statemachine.run_cycle()
		
		def __raise_done_moving_call(self):
			"""Raise callback for event done_moving.
			"""
			self.done_moving = True
		
	
	def __init__(self):
		""" Declares all necessary variables including list of states, histories etc. 
		"""
		self.scheduler = Statechart.Scheduler(self)
		self.emergency = Statechart.Emergency(self)
		self.crane_control = Statechart.CraneControl(self)
		
		self.in_event_queue = queue.Queue()
		self.SAFE_ALTITUDE = 100
		self.__target_x = None
		self.__target_y = None
		
		# enumeration of all states:
		self.__State = Statechart.State
		self.__state_conf_vector_changed = None
		self.__state_vector = [None] * 1
		for __state_index in range(1):
			self.__state_vector[__state_index] = self.State.null_state
		
		# for timed statechart:
		self.timer_service = None
		self.__time_events = [None] * 1
		
		# initializations:
		#Default init sequence for statechart Statechart
		self.__target_x = -(1)
		self.__target_y = -(1)
		self.__is_executing = False
	
	def is_active(self):
		"""Checks if the state machine is active.
		"""
		return self.__state_vector[0] is not self.__State.null_state
	
	def is_final(self):
		"""Checks if the statemachine is final.
		Always returns 'false' since this state machine can never become final.
		"""
		return False
			
	def is_state_active(self, state):
		"""Checks if the state is currently active.
		"""
		s = state
		if s == self.__State.global_moving_back_and_forth:
			return (self.__state_vector[0] >= self.__State.global_moving_back_and_forth)\
				and (self.__state_vector[0] <= self.__State.global_moving_back_and_forth_r1moving)
		if s == self.__State.global_moving_back_and_forth_r1moving_back:
			return self.__state_vector[0] == self.__State.global_moving_back_and_forth_r1moving_back
		if s == self.__State.global_moving_back_and_forth_r1moving:
			return self.__state_vector[0] == self.__State.global_moving_back_and_forth_r1moving
		if s == self.__State.global_tired:
			return self.__state_vector[0] == self.__State.global_tired
		return False
		
	def time_elapsed(self, event_id):
		"""Add time events to in event queue
		"""
		if event_id in range(1):
			self.in_event_queue.put(lambda: self.raise_time_event(event_id))
			self.run_cycle()
	
	def raise_time_event(self, event_id):
		"""Raise timed events using the event_id.
		"""
		self.__time_events[event_id] = True
	
	def __execute_queued_event(self, func):
		func()
	
	def __get_next_event(self):
		if not self.in_event_queue.empty():
			return self.in_event_queue.get()
		return None
	
	
	def __entry_action_global_moving_back_and_forth(self):
		"""Entry action for state 'MovingBackAndForth'..
		"""
		#Entry action for state 'MovingBackAndForth'.
		self.timer_service.set_timer(self, 0, (10 * 1000), False)
		
	def __entry_action_global_moving_back_and_forth_r1_moving_back(self):
		"""Entry action for state 'MovingBack'..
		"""
		#Entry action for state 'MovingBack'.
		self.crane_control.move_observable.next(0)
		
	def __entry_action_global_moving_back_and_forth_r1_moving(self):
		"""Entry action for state 'Moving'..
		"""
		#Entry action for state 'Moving'.
		self.crane_control.move_observable.next(10)
		
	def __entry_action_global_tired(self):
		"""Entry action for state 'Tired'..
		"""
		#Entry action for state 'Tired'.
		self.crane_control.stop_all_movement_observable.next()
		
	def __exit_action_global_moving_back_and_forth(self):
		"""Exit action for state 'MovingBackAndForth'..
		"""
		#Exit action for state 'MovingBackAndForth'.
		self.timer_service.unset_timer(self, 0)
		
	def __enter_sequence_global_moving_back_and_forth_default(self):
		"""'default' enter sequence for state MovingBackAndForth.
		"""
		#'default' enter sequence for state MovingBackAndForth
		self.__entry_action_global_moving_back_and_forth()
		self.__enter_sequence_global_moving_back_and_forth_r1_default()
		
	def __enter_sequence_global_moving_back_and_forth_r1_moving_back_default(self):
		"""'default' enter sequence for state MovingBack.
		"""
		#'default' enter sequence for state MovingBack
		self.__entry_action_global_moving_back_and_forth_r1_moving_back()
		self.__state_vector[0] = self.State.global_moving_back_and_forth_r1moving_back
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_global_moving_back_and_forth_r1_moving_default(self):
		"""'default' enter sequence for state Moving.
		"""
		#'default' enter sequence for state Moving
		self.__entry_action_global_moving_back_and_forth_r1_moving()
		self.__state_vector[0] = self.State.global_moving_back_and_forth_r1moving
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_global_tired_default(self):
		"""'default' enter sequence for state Tired.
		"""
		#'default' enter sequence for state Tired
		self.__entry_action_global_tired()
		self.__state_vector[0] = self.State.global_tired
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_global_default(self):
		"""'default' enter sequence for region global.
		"""
		#'default' enter sequence for region global
		self.__react_global__entry_default()
		
	def __enter_sequence_global_moving_back_and_forth_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_global_moving_back_and_forth_r1__entry_default()
		
	def __exit_sequence_global_moving_back_and_forth(self):
		"""Default exit sequence for state MovingBackAndForth.
		"""
		#Default exit sequence for state MovingBackAndForth
		self.__exit_sequence_global_moving_back_and_forth_r1()
		self.__state_vector[0] = self.State.null_state
		self.__exit_action_global_moving_back_and_forth()
		
	def __exit_sequence_global_moving_back_and_forth_r1_moving_back(self):
		"""Default exit sequence for state MovingBack.
		"""
		#Default exit sequence for state MovingBack
		self.__state_vector[0] = self.State.global_moving_back_and_forth
		
	def __exit_sequence_global_moving_back_and_forth_r1_moving(self):
		"""Default exit sequence for state Moving.
		"""
		#Default exit sequence for state Moving
		self.__state_vector[0] = self.State.global_moving_back_and_forth
		
	def __exit_sequence_global_tired(self):
		"""Default exit sequence for state Tired.
		"""
		#Default exit sequence for state Tired
		self.__state_vector[0] = self.State.null_state
		
	def __exit_sequence_global(self):
		"""Default exit sequence for region global.
		"""
		#Default exit sequence for region global
		state = self.__state_vector[0]
		if state == self.State.global_moving_back_and_forth:
			self.__exit_sequence_global_moving_back_and_forth()
		elif state == self.State.global_moving_back_and_forth_r1moving_back:
			self.__exit_sequence_global_moving_back_and_forth_r1_moving_back()
			self.__exit_action_global_moving_back_and_forth()
		elif state == self.State.global_moving_back_and_forth_r1moving:
			self.__exit_sequence_global_moving_back_and_forth_r1_moving()
			self.__exit_action_global_moving_back_and_forth()
		elif state == self.State.global_tired:
			self.__exit_sequence_global_tired()
		
	def __exit_sequence_global_moving_back_and_forth_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[0]
		if state == self.State.global_moving_back_and_forth_r1moving_back:
			self.__exit_sequence_global_moving_back_and_forth_r1_moving_back()
		elif state == self.State.global_moving_back_and_forth_r1moving:
			self.__exit_sequence_global_moving_back_and_forth_r1_moving()
		
	def __react_global_moving_back_and_forth_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_global_moving_back_and_forth_r1_moving_default()
		
	def __react_global__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_global_moving_back_and_forth_default()
		
	def __react(self, transitioned_before):
		"""Implementation of __react function.
		"""
		#State machine reactions.
		return transitioned_before
	
	
	def __global_moving_back_and_forth_react(self, transitioned_before):
		"""Implementation of __global_moving_back_and_forth_react function.
		"""
		#The reactions of state MovingBackAndForth.
		transitioned_after = transitioned_before
		if transitioned_after < 0:
			if self.__time_events[0]:
				self.__exit_sequence_global_moving_back_and_forth()
				self.__time_events[0] = False
				self.__enter_sequence_global_tired_default()
				self.__react(0)
				transitioned_after = 0
		#If no transition was taken
		if transitioned_after == transitioned_before:
			#then execute local reactions.
			transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __global_moving_back_and_forth_r1_moving_back_react(self, transitioned_before):
		"""Implementation of __global_moving_back_and_forth_r1_moving_back_react function.
		"""
		#The reactions of state MovingBack.
		transitioned_after = transitioned_before
		if transitioned_after < 0:
			if self.crane_control.done_moving:
				self.__exit_sequence_global_moving_back_and_forth_r1_moving_back()
				self.__enter_sequence_global_moving_back_and_forth_r1_moving_default()
				self.__global_moving_back_and_forth_react(0)
				transitioned_after = 0
		#If no transition was taken
		if transitioned_after == transitioned_before:
			#then execute local reactions.
			transitioned_after = self.__global_moving_back_and_forth_react(transitioned_before)
		return transitioned_after
	
	
	def __global_moving_back_and_forth_r1_moving_react(self, transitioned_before):
		"""Implementation of __global_moving_back_and_forth_r1_moving_react function.
		"""
		#The reactions of state Moving.
		transitioned_after = transitioned_before
		if transitioned_after < 0:
			if self.crane_control.done_moving:
				self.__exit_sequence_global_moving_back_and_forth_r1_moving()
				self.__enter_sequence_global_moving_back_and_forth_r1_moving_back_default()
				self.__global_moving_back_and_forth_react(0)
				transitioned_after = 0
		#If no transition was taken
		if transitioned_after == transitioned_before:
			#then execute local reactions.
			transitioned_after = self.__global_moving_back_and_forth_react(transitioned_before)
		return transitioned_after
	
	
	def __global_tired_react(self, transitioned_before):
		"""Implementation of __global_tired_react function.
		"""
		#The reactions of state Tired.
		transitioned_after = transitioned_before
		#Always execute local reactions.
		transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __clear_in_events(self):
		"""Implementation of __clear_in_events function.
		"""
		self.scheduler.set_target_x = False
		self.scheduler.set_target_y = False
		self.scheduler.make_move = False
		self.emergency.stop = False
		self.emergency.resume = False
		self.crane_control.done_moving = False
		self.__time_events[0] = False
	
	
	def __micro_step(self):
		"""Implementation of __micro_step function.
		"""
		state = self.__state_vector[0]
		if state == self.State.global_moving_back_and_forth_r1moving_back:
			self.__global_moving_back_and_forth_r1_moving_back_react(-1)
		elif state == self.State.global_moving_back_and_forth_r1moving:
			self.__global_moving_back_and_forth_r1_moving_react(-1)
		elif state == self.State.global_tired:
			self.__global_tired_react(-1)
	
	
	def run_cycle(self):
		"""Implementation of run_cycle function.
		"""
		#Performs a 'run to completion' step.
		if self.timer_service is None:
			raise ValueError('Timer service must be set.')
		
		if self.__is_executing:
			return
		self.__is_executing = True
		next_event = self.__get_next_event()
		if next_event is not None:
			self.__execute_queued_event(next_event)
		condition_0 = True
		while condition_0:
			self.__micro_step()
			self.__clear_in_events()
			condition_0 = False
			next_event = self.__get_next_event()
			if next_event is not None:
				self.__execute_queued_event(next_event)
				condition_0 = True
		self.__is_executing = False
	
	
	def enter(self):
		"""Implementation of enter function.
		"""
		#Activates the state machine.
		if self.timer_service is None:
			raise ValueError('Timer service must be set.')
		
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default enter sequence for statechart Statechart
		self.__enter_sequence_global_default()
		self.__is_executing = False
	
	
	def exit(self):
		"""Implementation of exit function.
		"""
		#Deactivates the state machine.
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default exit sequence for statechart Statechart
		self.__exit_sequence_global()
		self.__state_vector[0] = self.State.null_state
		self.__is_executing = False
	
	
	def trigger_without_event(self):
		"""Implementation of triggerWithoutEvent function.
		"""
		self.run_cycle()
	
